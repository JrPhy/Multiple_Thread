生產者消費者問題是一個經典的多執行緒問題，也與現實生活中的情境非常類似。例如在糕點店，廚師會先將做好的商品放到架上供消費者選購，如果架上沒有了就先不生產，等到有空位在繼續生產，而當架上是空的時候消費者就等待生產。在此我們就簡化只生產一種產品，所以做好的產品會先被推到架上，而消費者就會先購買最先被推出的產品，如下圖所示，可以用 queue 來實作。
![image](https://ask.qcloudimg.com/http-save/yehe-5522483/5s05iyy43f.png) https://cloud.tencent.com/developer/article/1442055

## 1. 條件變數
在多執行緒中會使用 mutex 來保護某一段被兩個執行緒操作的區域，稱為 critical section，在此就是上圖中的 queue，生產者會放物件進去，消費者會取物件出來。此時就可以使用條件變數來通知其中一方，對於生產者來說，就是 queue 滿的時候由消費者鎖住，queue 空的時候由生產者鎖住。在此使用讀寫位置來判斷是否為空或滿，當讀寫位置相同時即為空，而當讀的位置 = (寫的位置+1)%容量時為滿。
|   | 生產者 | 消費者 |
| --- | :--- | :--- |
| 等待條件 | (write_position + 1) % capacity) == read_position | write_position == read_position |
| 條件變數 | repo_not_full | repo_not_empty |

在 C++ 中可以```#include <condition_variable>```使用 ```condition_variable```，C 中可使用 ```condition_variable``` 而當解除上面條件時，就可以通知正在等待的執行緒。[以下程式碼參考這裡](https://www.zywvvd.com/notes/coding/cpp/cpp-producer-consumer/cpp-producer-consumer/)
```cpp
#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>
 
static const int repository_size = 10;//循环队列的大小
static const int item_total = 20;//要生产的产品数目
 
std::mutex mtx;//互斥量，保护产品缓冲区
 
std::condition_variable repo_not_full;//条件变量指示产品缓冲区不满
std::condition_variable repo_not_empty;//条件变量指示产品缓冲区不为空，就是缓冲区有产品
 
int item_buffer[repository_size];
 
static std::size_t read_position = 0;//消费者读取产品的位置
static std::size_t write_position = 0;//生产者写入产品的位置
 
std::chrono::seconds t(1);
void produce_item(int i)
{
	std::unique_lock<std::mutex> lck(mtx);
	while (((write_position + 1) % repository_size) == read_position)
	{
		std::cout << "Producer is waiting for an empty slot..." << std::endl;
		repo_not_full.wait(lck); // 等待不為滿的條件
	}
    item_buffer[write_position] = i;// 寫入
	write_position++;
 
	write_position %= repository_size;// 環狀 queue

	repo_not_empty.notify_all(); // 不為空的時候就通知消費者執行緒
}

int consume_item()
{
	int data;
	std::unique_lock<std::mutex> lck(mtx);
	while (write_position == read_position)
	{
		std::cout << "Consumer is waiting for items..." << std::endl;
		repo_not_empty.wait(lck);// 等待不為空的條件
    }

    data = item_buffer[read_position];// 讀取
	read_position++;
 
	read_position %= repository_size;// 環狀 queue

	repo_not_full.notify_all();// 通知生產者有空位
	return data;
}
void Producer_thread()
{
	for (int i = 1; i <= item_total; ++i)
	{
		//std::this_thread::sleep_for(t);
		std::cout << "生產者生感第" << i  << "個產品" << std::endl;
		produce_item(i);
	}
}
 
void Consumer_thread()
{
	static int cnt = 0;
	while (1)
	{
		//std::this_thread::sleep_for(t);
		int item = consume_item();
		std::cout << "消費者消費第" << item << "個產品" << std::endl;
 
		if (++cnt == item_total) break;
	}
}
 
int main()
{
	std::thread producer(Producer_thread);
	std::thread consumer(Consumer_thread);
	producer.join();
	consumer.join();
}
```
